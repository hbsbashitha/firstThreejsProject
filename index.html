<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<meta http-equiv='X-UA-Compatible' content='IE=edge'>
	<title>My first three.js app</title>
	<meta name='viewport' content='width=device-width, initial-scale=1'>
	<script src='/build/three.js'></script>
	<script src='/examples/js/controls/OrbitControls.js'></script>
	<script src='lights.js'></script>
</head>

<body>
	<script>

		//scene and camera initialization
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.z = 5;

		//renderer initialization
		const renderer = new THREE.WebGLRenderer();
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		controls = new THREE.OrbitControls(camera, renderer.domElement);

		const axes=new THREE.AxesHelper();
		scene.add(axes);



		const planeGeometry = new THREE.PlaneGeometry(8, 1, 1);
		const planeMaterial = new THREE.MeshBasicMaterial({
			color: 0xb2beb5,
			side: THREE.DoubleSide
		});
		const plane = new THREE.Mesh(planeGeometry, planeMaterial);
		plane.rotation.x = -Math.PI / 7;
		plane.receiveShadow = true;
		plane.position.set(0,0,0);
		scene.add(plane);

		
		const sphereGeometry = new THREE.SphereGeometry(0.5, 100, 100);
		const sphereMaterial = new THREE.MeshBasicMaterial({
			color: 0X0000FF,
		});
		const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		sphere.castShadow = true;
		scene.add(sphere);
		sphere.position.set(3, 0.2, 0.5);

		const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
		const cubeMaterial = new THREE.MeshBasicMaterial({
			color: 0xFF0000,
		});
		const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
		cube.castShadow = true;
		scene.add(cube);
		cube.position.set(-2, 0, 0);
		cube.rotation=-Math.PI / 7;

		
		step = 0;

		var render = () => {
			renderer.render(scene, camera);
		}
		var update = () => {
			cube.rotation.x += 0.02;
			// step += 0.04;
			// sphere.position.y += (0.5*Math.cos(step))+0.01;
		}


		var gameLoop = () => {

			update();
			render();
			requestAnimationFrame(gameLoop);
		}
		gameLoop();


		window.addEventListener("resize", () => {
			renderer.setSize(window.innerWidth, window.innerHeight);
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
		});

	</script>

</body>

</html>
